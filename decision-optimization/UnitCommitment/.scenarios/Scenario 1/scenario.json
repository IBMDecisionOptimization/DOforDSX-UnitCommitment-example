{"qualifiers":[{"name":"modelType","value":"python"},{"name":"modelMetadata","value":"{\"fileName\":\"model.py\",\"fileContent\":\"\\r\\nfrom docplex.mp.environment import Environment\\r\\nfrom docplex.mp.model import Model\\r\\nimport pandas as pd\\r\\n\\r\\nurl = None\\r\\nkey = None\\r\\n\\r\\ndf_units = inputs['units']\\r\\ndf_units.set_index(df_units[\\\"units\\\"], inplace=True)\\r\\ndf_periods = inputs['periods']\\r\\ndf_periods.set_index(df_periods[\\\"id\\\"], inplace=True)\\r\\ndf_loads = inputs['loads']\\r\\ndf_loads.set_index(df_loads[\\\"period\\\"], inplace=True)\\r\\n\\r\\nrobust = 0\\r\\n\\r\\nenv = Environment()\\r\\n#env.print_information()\\r\\n\\r\\nucpm = Model(\\\"ucp\\\")\\r\\nn_starts = None\\r\\n\\r\\nunits = df_units['units'].values.tolist()\\r\\n\\r\\nnb_periods = len(df_periods)\\r\\n\\r\\n# periods range from 1 to nb_periods included\\r\\nperiods = range(1, nb_periods+1)\\r\\n\\r\\n# in use[u,t] is true iff unit u is in production at period t\\r\\nin_use = ucpm.binary_var_matrix(keys1=units, keys2=periods, name=\\\"in_use\\\")\\r\\n\\r\\n# true if unit u is turned on at period t\\r\\nturn_on = ucpm.binary_var_matrix(keys1=units, keys2=periods, name=\\\"turn_on\\\")\\r\\n\\r\\n# true if unit u is switched off at period t\\r\\n# modeled as a continuous 0-1 variable, more on this later\\r\\nturn_off = ucpm.continuous_var_matrix(keys1=units, keys2=periods, lb=0, ub=1, name=\\\"turn_off\\\")\\r\\n\\r\\n# production of energy for unit u at period t\\r\\nproduction = ucpm.continuous_var_matrix(keys1=units, keys2=periods, name=\\\"production\\\")\\r\\n\\r\\n# Organize all decision variables in a DataFrame indexed by 'units' and 'periods'\\r\\ndf_decision_vars = pd.DataFrame({'in_use': in_use, 'turn_on': turn_on, 'turn_off': turn_off, 'production': production})\\r\\n\\r\\n# Set index names\\r\\ndf_decision_vars.index.names=['units', 'periods']\\r\\n\\r\\n# Create a join between 'df_decision_vars' and 'df_up' Data Frames based on common index id (ie: 'units')\\r\\n# In 'df_up', one keeps only relevant columns: 'min_gen' and 'max_gen'\\r\\ndf_join_decision_vars_up = df_decision_vars.join(df_units[['min_generation', 'max_generation']], how='inner')\\r\\n\\r\\n# When in use, the production level is constrained to be between min and max generation.\\r\\nfor item in df_join_decision_vars_up.itertuples(index=False):\\r\\n\\tucpm += (item.production <= item.max_generation * item.in_use)\\r\\n\\tucpm += (item.production >= item.min_generation * item.in_use)\\r\\n\\t\\r\\n# Initial state\\r\\n# If initial production is nonzero, then period #1 is not a turn_on\\r\\n# else turn_on equals in_use\\r\\n# Dual logic is implemented for turn_off\\r\\nfor u in units:\\r\\n\\tif df_units.init_prod_level[u] > 0:\\r\\n\\t\\t# if u is already running, not starting up\\r\\n\\t\\tucpm.add_constraint(turn_on[u, 1] == 0)\\r\\n\\t\\t# turnoff iff not in use\\r\\n\\t\\tucpm.add_constraint(turn_off[u, 1] + in_use[u, 1] == 1)\\r\\n\\telse:\\r\\n\\t\\t# turn on at 1 iff in use at 1\\r\\n\\t\\tucpm.add_constraint(turn_on[u, 1] == in_use[u, 1])\\r\\n\\t\\t# already off, not switched off at t==1\\r\\n\\t\\tucpm.add_constraint(turn_off[u, 1] == 0)\\r\\n\\t\\t\\r\\n# Use groupby operation to process each unit\\r\\nfor unit, r in df_decision_vars.groupby(level='units'):\\r\\n\\tu_ramp_up = df_units.ramp_up[unit]\\r\\n\\tu_ramp_down = df_units.ramp_down[unit]\\r\\n\\tu_initial = df_units.init_prod_level[unit]\\r\\n\\t# Initial ramp up/down\\r\\n\\t# Note that r.production is a Series that can be indexed as an array (ie: first item index = 0)\\r\\n\\tucpm.add_constraint(r.production[0] - u_initial <= u_ramp_up)\\r\\n\\tucpm.add_constraint(u_initial - r.production[0] <= u_ramp_down)\\r\\n\\tfor (p_curr, p_next) in zip(r.production, r.production[1:]):\\r\\n\\t\\tucpm.add_constraint(p_next - p_curr <= u_ramp_up)\\r\\n\\t\\tucpm.add_constraint(p_curr - p_next <= u_ramp_down)         \\r\\n\\t\\t\\r\\n# Turn_on, turn_off\\r\\n# Use groupby operation to process each unit\\r\\nfor unit, r in df_decision_vars.groupby(level='units'):\\r\\n\\tfor (in_use_curr, in_use_next, turn_on_next, turn_off_next) in zip(r.in_use, r.in_use[1:], r.turn_on[1:], r.turn_off[1:]):\\r\\n\\t\\t# if unit is off at time t and on at time t+1, then it was turned on at time t+1\\r\\n\\t\\tucpm.add_constraint(in_use_next - in_use_curr <= turn_on_next)\\r\\n\\r\\n\\t\\t# if unit is on at time t and time t+1, then it was not turned on at time t+1\\r\\n\\t\\t# mdl.add_constraint(in_use_next + in_use_curr + turn_on_next <= 2)\\r\\n\\r\\n\\t\\t# if unit is on at time t and off at time t+1, then it was turned off at time t+1\\r\\n\\t\\tucpm.add_constraint(in_use_curr - in_use_next + turn_on_next == turn_off_next)        \\r\\n\\t\\t\\r\\n# Minimum uptime, downtime\\r\\nfor unit, r in df_decision_vars.groupby(level='units'):\\r\\n\\tmin_uptime   = df_units.min_up[unit]\\r\\n\\tmin_downtime = df_units.min_down[unit]\\r\\n\\t# Note that r.turn_on and r.in_use are Series that can be indexed as arrays (ie: first item index = 0)\\r\\n\\tfor t in range(min_uptime, nb_periods):\\r\\n\\t\\tctname = \\\"min_up_{0!s}_{1}\\\".format(*r.index[t])\\r\\n\\t\\tucpm.add_constraint(ucpm.sum(r.turn_on[(t - min_uptime) + 1:t + 1]) <= r.in_use[t], ctname)\\r\\n\\r\\n\\tfor t in range(min_downtime, nb_periods):\\r\\n\\t\\tctname = \\\"min_down_{0!s}_{1}\\\".format(*r.index[t])\\r\\n\\t\\tucpm.add_constraint(ucpm.sum(r.turn_off[(t - min_downtime) + 1:t + 1]) <= 1 - r.in_use[t], ctname)\\r\\n\\t\\t\\r\\n# Enforcing demand\\r\\n# we use a >= here to be more robust, \\r\\n# objective will ensure  we produce efficiently\\r\\nfor period, r in df_decision_vars.groupby(level='periods'):\\r\\n\\ttotal_demand = df_loads.load[period]\\r\\n\\tctname = \\\"ct_meet_demand_%d\\\" % period\\r\\n\\tucpm.add_constraint(ucpm.sum(r.production) >= total_demand + robust, ctname) \\r\\n\\t\\r\\n# Predefined usage\\r\\nif 'used' in inputs:\\r\\n\\tdf_used = inputs['used']\\r\\n\\tfor p in periods:\\r\\n\\t\\tfor u in units:\\r\\n\\t\\t\\tucpm.add_constraint(in_use[u, p] == df_used[u][p])\\r\\n\\t\\t\\t\\r\\n# Create a join between 'df_decision_vars' and 'df_up' Data Frames based on common index ids (ie: 'units')\\r\\n# In 'df_up', one keeps only relevant columns: 'fixed_cost', 'variable_cost', 'start_cost' and 'co2_cost'\\r\\ndf_join_obj = df_decision_vars.join(\\r\\n\\tdf_units[['constant_cost', 'linear_cost', 'start_up_cost', 'co2_cost']], how='inner')        \\r\\n\\t\\t\\r\\n# objective\\r\\ntotal_fixed_cost = ucpm.sum(df_join_obj.in_use * df_join_obj.constant_cost)\\r\\ntotal_variable_cost = ucpm.sum(df_join_obj.production * df_join_obj.linear_cost)\\r\\ntotal_startup_cost = ucpm.sum(df_join_obj.turn_on * df_join_obj.start_up_cost)\\r\\ntotal_co2_cost = ucpm.sum(df_join_obj.production * df_join_obj.co2_cost)\\r\\ntotal_economic_cost = total_fixed_cost + total_variable_cost + total_startup_cost\\r\\ntotal_cost = total_economic_cost + total_co2_cost\\r\\n\\r\\ntotal_nb_used = ucpm.sum(df_decision_vars.in_use)\\r\\ntotal_nb_starts = ucpm.sum(df_decision_vars.turn_on)\\r\\n\\r\\nif (n_starts is not None):\\r\\n\\tucpm.add_constraint(total_nb_starts == n_starts)\\r\\n\\r\\n# store expression kpis to retrieve them later.\\r\\nucpm.add_kpi(total_fixed_cost   , \\\"Total Fixed Cost\\\")\\r\\nucpm.add_kpi(total_variable_cost, \\\"Total Variable Cost\\\")\\r\\nucpm.add_kpi(total_startup_cost , \\\"Total Startup Cost\\\")\\r\\nucpm.add_kpi(total_economic_cost, \\\"Total Economic Cost\\\")\\r\\nucpm.add_kpi(total_co2_cost     , \\\"Total CO2 Cost\\\")\\r\\nucpm.add_kpi(total_cost         , \\\"Total Cost\\\")\\r\\nucpm.add_kpi(total_nb_used, \\\"Total #used\\\")\\r\\nucpm.add_kpi(total_nb_starts, \\\"Total #starts\\\")\\r\\n\\r\\n# minimize sum of all costs\\r\\nucpm.minimize(total_fixed_cost + total_variable_cost + total_startup_cost + total_co2_cost)\\r\\n\\r\\nif ucpm.solve(url=url, key=key):\\r\\n\\tprint \\\"  Feasible \\\" + str(ucpm.objective_value)\\r\\n\\r\\n\\tdf_prods = df_decision_vars.production.apply(lambda v: v.solution_value).unstack(level='units')\\r\\n\\tdf_used = df_decision_vars.in_use.apply(lambda v: v.solution_value).unstack(level='units')\\r\\n\\tdf_started = df_decision_vars.turn_on.apply(lambda v: v.solution_value).unstack(level='units')\\r\\n\\r\\n\\tall_kpis = [(kp.name, kp.compute()) for kp in ucpm.iter_kpis()]\\r\\n\\tall_kpis.append((\\\"Feasibility\\\", 1))\\r\\n\\tkpis_bd = pd.DataFrame(all_kpis, columns=['kpi', 'value'])\\r\\n\\r\\n\\tdf_production = df_prods.copy()\\r\\n\\tdf_production = df_production.stack(level='units').to_frame()\\r\\n\\tdf_production['units'] = df_production.index.get_level_values('units') \\r\\n\\tdf_production['periods'] = df_production.index.get_level_values('periods') \\r\\n\\tdf_production.columns = ['value', 'units', 'periods'] \\r\\n\\tdf_production = df_production.reset_index(drop=True)\\r\\n\\toutputs = {}\\r\\n\\toutputs['production'] = df_production\\r\\n\\toutputs['prods'] = df_prods\\r\\n\\toutputs['used'] = df_used\\r\\n\\toutputs['started'] = df_started\\r\\n\\toutputs['kpis'] = kpis_bd\\r\\nelse:\\r\\n\\tprint \\\"  Infeasible\\\"\\r\\n\\tall_kpis= [(\\\"Feasibility\\\", 0)]\\r\\n\\tkpis_bd = pd.DataFrame(all_kpis, columns=['kpi', 'value'])\\r\\n\\toutputs = {}\\r\\n\\toutputs['kpis'] = kpis_bd\\r\\n\",\"lastUploadTime\":1523426671116}"}],"parentId":"UnitCommitment","category":"scenario","creator":"alain","createdAt":1523426648985,"usage":{"lastModificationTime":1523426726842,"lastModifier":"alain"},"dataUsagePerCategory":{"input":{"lastModificationTime":1523426658564,"lastModifier":"alain"},"model":{"lastModificationTime":1523426669457,"lastModifier":"alain"},"output":{"lastModificationTime":1523426726842,"lastModifier":"alain"}},"state":"available","tables":[{"tableType":{"columns":[{"key":"id","dataType":"Number"},{"key":"day","dataType":"String"},{"key":"time_of_day","dataType":"String"}]},"name":"periods","category":"input","lineage":"Copied from periods.csv","numberOfRows":168,"creator":"alain","createdAt":1523426658135,"lastUpdater":"alain","updatedAt":1523426658495,"path":"../../../../datasets/periods.csv"},{"tableType":{"columns":[{"key":"units","dataType":"String"},{"key":"type","dataType":"String"},{"key":"init_prod_level","dataType":"Number"},{"key":"min_generation","dataType":"Number"},{"key":"max_generation","dataType":"Number"},{"key":"operating_max_gen","dataType":"Number"},{"key":"min_up","dataType":"Number"},{"key":"min_down","dataType":"Number"},{"key":"ramp_up","dataType":"Number"},{"key":"ramp_down","dataType":"Number"},{"key":"start_up_cost","dataType":"Number"},{"key":"constant_cost","dataType":"Number"},{"key":"linear_cost","dataType":"Number"},{"key":"co2_cost","dataType":"Number"}]},"name":"units","category":"input","lineage":"Copied from units.csv","numberOfRows":10,"creator":"alain","createdAt":1523426658160,"lastUpdater":"alain","updatedAt":1523426658375,"path":"../../../../datasets/units.csv"},{"tableType":{"columns":[{"key":"load","dataType":"Number"},{"key":"period","dataType":"Number"}]},"name":"loads","category":"input","lineage":"Copied from loads.csv","numberOfRows":168,"creator":"alain","createdAt":1523426658282,"lastUpdater":"alain","updatedAt":1523426658564,"path":"../../../../datasets/loads.csv"},{"tableType":{"columns":[{"key":"kpi","dataType":"String"},{"key":"value","dataType":"Number"}]},"name":"kpis","category":"output","numberOfRows":9,"creator":"alain","createdAt":1523426726025,"lastUpdater":"alain","updatedAt":1523426726025,"path":"kpis.csv"},{"tableType":{"columns":[{"key":"COAL_1","dataType":"Number"},{"key":"COAL_2","dataType":"Number"},{"key":"DIESEL_1","dataType":"Number"},{"key":"DIESEL_2","dataType":"Number"},{"key":"DIESEL_3","dataType":"Number"},{"key":"DIESEL_4","dataType":"Number"},{"key":"GAS_1","dataType":"Number"},{"key":"GAS_2","dataType":"Number"},{"key":"GAS_3","dataType":"Number"},{"key":"GAS_4","dataType":"Number"}]},"name":"used","category":"output","numberOfRows":168,"creator":"alain","createdAt":1523426726268,"lastUpdater":"alain","updatedAt":1523426726268,"path":"used.csv"},{"tableType":{"columns":[{"key":"COAL_1","dataType":"Number"},{"key":"COAL_2","dataType":"Number"},{"key":"DIESEL_1","dataType":"Number"},{"key":"DIESEL_2","dataType":"Number"},{"key":"DIESEL_3","dataType":"Number"},{"key":"DIESEL_4","dataType":"String"},{"key":"GAS_1","dataType":"Number"},{"key":"GAS_2","dataType":"Number"},{"key":"GAS_3","dataType":"Number"},{"key":"GAS_4","dataType":"Number"}]},"name":"prods","category":"output","numberOfRows":168,"creator":"alain","createdAt":1523426726462,"lastUpdater":"alain","updatedAt":1523426726462,"path":"prods.csv"},{"tableType":{"columns":[{"key":"value","dataType":"String"},{"key":"units","dataType":"String"},{"key":"periods","dataType":"Number"}]},"name":"production","category":"output","numberOfRows":1680,"creator":"alain","createdAt":1523426726579,"lastUpdater":"alain","updatedAt":1523426726579,"path":"production.csv"},{"tableType":{"columns":[{"key":"COAL_1","dataType":"Number"},{"key":"COAL_2","dataType":"Number"},{"key":"DIESEL_1","dataType":"Number"},{"key":"DIESEL_2","dataType":"Number"},{"key":"DIESEL_3","dataType":"Number"},{"key":"DIESEL_4","dataType":"Number"},{"key":"GAS_1","dataType":"Number"},{"key":"GAS_2","dataType":"Number"},{"key":"GAS_3","dataType":"Number"},{"key":"GAS_4","dataType":"Number"}]},"name":"started","category":"output","numberOfRows":168,"creator":"alain","createdAt":1523426726842,"lastUpdater":"alain","updatedAt":1523426726842,"path":"started.csv"}],"assets":[{"name":"model.py","category":"model","creator":"alain","createdAt":1523426669457,"lastUpdater":"alain","updatedAt":1523426669457,"contentType":"application/json","path":"model.py"},{"name":"log.txt","category":"output","creator":"alain","createdAt":1523426726674,"lastUpdater":"alain","updatedAt":1523426726674,"path":"log.txt"}]}